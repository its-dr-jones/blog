{"id":56,"date":"2017-11-11T16:45:22","date_gmt":"2017-11-11T16:45:22","guid":{"rendered":"https:\/\/xpoc.pro\/?p=56"},"modified":"2022-04-24T00:51:37","modified_gmt":"2022-04-23T21:51:37","slug":"how-idor-in-the-facebook-game-turned-me-from-the-dev-to-the-security-researcher","status":"publish","type":"post","link":"https:\/\/xp.ht\/how-idor-in-the-facebook-game-turned-me-from-the-dev-to-the-security-researcher\/","title":{"rendered":"How Access Control issue in the Facebook game turned me from the dev to the security researcher"},"content":{"rendered":"<p style=\"text-align: justify;\">Hello. Since it is my first blog post, I&#8217;ll start my stories from the beginning &#8211; from the first bug, which made me seriously think about infosec career.<!--more--><\/p>\n<p style=\"text-align: justify;\">It was the May 2016, and I played with friends in the online game, located on the<\/p>\n<pre>https:\/\/apps.facebook.com\/xxxxxxx<\/pre>\n<p>(I can&#8217;t disclose game title, but I will try to highlight as much info as possible) on Facebook that time. It was the usual strategy, with economics, clan system, tower defense\/attack modes, PvP, PvE, etc. And, for sure, a premium store system, where players could buy premium cash, boosters, items, and other stuff. All payments were made through the Facebook payment gateway.<\/p>\n<p style=\"text-align: justify;\">Because I had a lot of free time, I started to research, how the game works (authentication, request\/response format, etc). Using Chrome&#8217;s Web Debugger, I discovered, that application uses XML format (nope, XXE didn&#8217;t work) for data exchange. At the authentication phase it used Facebook profile ID in combination with unique authentication_key to obtain the session_key:<\/p>\n<pre>&lt;authenticate fb_id=\"[facebook id]\" authenticity_key=\"[32-symbol static md5 signature, unique for the each Facebook user]\"&gt;<\/pre>\n<p>And the response was:<\/p>\n<pre>&lt;response&gt;\n&lt;session&gt;[32-symbol md5 session signature]&lt;\/session&gt;\n&lt;\/response&gt;<\/pre>\n<p>All next requests simply used this session value.<br \/>\nMost of the game actions used next schema:<\/p>\n<pre>&lt;command fb_id=\"[facebook id]\" authenticity_key=\"[key signature]\" session=\"[session signature]\"&gt;\n&lt;action&gt;[some ingame action]&lt;\/action&gt;\n&lt;\/command&gt;<\/pre>\n<p style=\"text-align: justify;\">On this stage, I was able to automate some simple boring resource crafting actions (if you are familiar with social games, you know what I mean), using custom written PHP script &#8211; so no more need to be online, script will do crafting job 24\/7, using cron (authentication-&gt;making actions-&gt;finish).<br \/>\nNext, I started thinking, how the game client knows, which action it needs to send to the server? Obviously, there was some database with request schemas on the client. Because debugger didn&#8217;t find anything, I decided to reverse the game client to figure out how things work. It was a flash application, so reversing to the Action Script didn&#8217;t take much time.<br \/>\nI was familiar with Action Script and Flash apps in the past, so quickly found what I looked for. Upon the game initialization, there was a request to the ZLib-compressed file on the game server, which was then decompressed, and used to issue the requests.<br \/>\nSo, I downloaded that file and decompressed it using 7-Zip File Manager, which support ZLib. The file was 1Mb compressed&nbsp;and became around 102Mb decompressed. After looking inside I was surprised &#8211; it contained schemas for all possible actions and requests, in XML format. Some of this commands were never issued by the game client, so couldn&#8217;t be discovered in another way. Manual inspection could take weeks, due to the big amount of the information inside, so I went short way &#8211; I created the C# script, which extracted all possible strings from the file, formed the new file from them (with each string from newline) and implemented the loop, to issue requests to the game server with each string (there was around 100k of total). Here is a piece of C# code:<\/p>\n<pre>StreamReader rs = new StreamReader(\"scripts.txt\"); \/\/file with extracted strings\nStreamWriter ws = new StreamWriter(\"out.txt\"); \/\/output file\nfbid = \"[myid]\";\nkey = \"[mykey]\";\nwhile (!rs.EndOfStream) {\nrequests = rs.ReadLine;\nauthorize(); \/\/auth function, returns and defines session as global var\npostdata = \"&lt;command uid=\\\"\" + fb_id + \"\\\" authenticity_key=\\\"\" +\nkey + \"\\\" session=\\\"\" +session + \"\\\"&gt;&lt;action&gt;\" + requests + \"&lt;\/action&gt;&lt;\/command&gt;\";\nresponsepc = network(postdata, \"https:\/\/[game host]\/\", \"[api path]\");\nif (!responsepc.Contains(\"error\")) {\nws.WriteLine(postdata);\nws.WriteLine(responsepc);\n}\n}\nws.Close();\nrs.Close();\n\n\npublic string network(string postdata, string host, string mode)\n{\nHttpWebRequest request;\nHttpWebResponse response;\nStream requestStream;\nbyte[] postBytes = null;\nSystem.IO.StreamReader responseReader;\nSystem.IO.Stream responseStream;\nstring responseText = \"\";\ntry {\nrequest = (HttpWebRequest)WebRequest.Create(host + mode);\nrequest.ContentType = \"application\/x-www-form-urlencoded\";\nrequest.ContentLength = postdata.Length;\nrequest.Accept = \"*\/*\";a\nrequest.ServicePoint.Expect100Continue = false;\nrequest.Method = \"POST\";\nrequest.AllowAutoRedirect = false;\nrequestStream = request.GetRequestStream();\npostBytes = System.Text.Encoding.ASCII.GetBytes(postdata);\nrequestStream.Write(postBytes, 0, postBytes.Length);\nrequestStream.Close();\nresponse = (HttpWebResponse)request.GetResponse();\nresponseStream = response.GetResponseStream();\nresponseReader = new IO.StreamReader(responseStream);\nresponseText = responseReader.ReadToEnd();\n} catch (Exception ex) {}\nreturn responseText;\n}\n<\/pre>\n<p style=\"text-align: justify;\">I launched the tool&nbsp;and went to sleep. The next morning I had the huge backlog of successful responses.<\/p>\n<p style=\"text-align: justify;\"><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-94\" src=\"https:\/\/xp.ht\/wp-content\/uploads\/2017\/11\/enot.gif\" alt=\"\" width=\"225\" height=\"300\"><br \/>\nAfter 15 minutes of reading, I was surprised &#8211; one response showed, that some command bypassed the game payments system, and credited me the big amount of premium game cash. I repeated this command &#8211; and got another portion of cash. Every single command produced game cash, equivalent to the $200 real money &#8211; and I could use it without limits! Sounds like the&nbsp;backdoor. Possibly, this command was used by devs on the development stage, and they forgot to remove it after making the payment system. This bug couldn&#8217;t be discovered without reversing &#8211; because this command was never used by the app.<\/p>\n<p style=\"text-align: justify;\">Well, it was something. The game was popular enough, had more than 100 000 players, and the&nbsp;potential attacker could impact company economic on tens of thousands of dollars by selling the premium cash cheaper&#8230; Realize this &#8211; if even 5000 of the 100 000 players decide to buy the game cash cheaper (let&#8217;s say, for 100$) from the hacker &#8211; it&#8217;s 500 000$ profit. For sure, such activity had all chances to be spotted and prevented, but still.<br \/>\nAfter this, I permitted similar technique against other games of this company &#8211; and successfully broke 3 more games! Bump.<\/p>\n<p style=\"text-align: justify;\">I reported this bug to the company, and they issued a reward&#8230; which was a lot lower from the theoretical profit of attacker:) But I was not a blackhat, and accepted the reward with gratitude. That&#8217;s how I first discovered bug bounties.<br \/>\nIn the next months, I discovered similar findings in other Flash-based social games &#8211; and I must say, that data encryption and format does not matter. Reversing the Flash application will allow the attacker to understand the data format, and how encryption works &#8211; and then permit fuzzing against the game server. It can be hardened\/mitigated in several ways&#8230;But it is a different story.<\/p>\n<p>After this finding, I believed that I can be of use for the security field, and discovered such platforms as HackerOne and BugCrowd. I registered on both but started working on the HackerOne only in the November 2016, after months of learning and practice (since I was a dev before, the learning was not very hard).<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Hello. Since it is my first blog post, I&#8217;ll start my stories from the beginning &#8211; from the first bug, which made me seriously think about infosec career.<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[2],"tags":[],"_links":{"self":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts\/56"}],"collection":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/comments?post=56"}],"version-history":[{"count":8,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts\/56\/revisions"}],"predecessor-version":[{"id":653,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/posts\/56\/revisions\/653"}],"wp:attachment":[{"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/media?parent=56"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/categories?post=56"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/xp.ht\/wp-json\/wp\/v2\/tags?post=56"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}